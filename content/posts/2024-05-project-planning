---
title: "Agile Software Architecture"

date: 2024-04-28T10:20:44+02:00

draft: true

description: Architecture is no longer a set of diagrams that define upfront how features are implemented, but continously growing and evolving set of decisions

tags: [ "Development", "Agile"]
---

{{< lead >}}
 Architecture is no longer a set of diagrams that define upfront how features are implemented, but continously growing and evolving set of decisions
{{< /lead >}}

## Agile Architecture

One change that came with the agile culture was replacing detailed architecture plans and class structure diagrams "YAGNI" mentality of only developing the current ticket loosing overview over the bigger picture. Both extremes are not practical and will end up in an agile architecture. 

{{<quote>
The phrase “Agile architecture” evokes two concepts:
1. A system or software architecture that is versatile, easy to evolve, and easy to modify, while resilient enough not to degrade after a few changes.
2. An Agile way to define an architecture, using an iterative lifecycle, allowing the architectural design to tactically evolve over time, as the problem and the constraints are better understood.
{{</quote>
[^agileArchitecture]

[^agileArchitecture]: [How to Agilely Architect an Agile Architecture](https://insights.sei.cmu.edu/documents/1395/2014_101_001_493902.pdf)

In every software project there are decisions that need to be done upfront, that will highly influence the architecture of the project - programming language, database decision, authentication, patterns ... 
These decisions should not be solved by the first feature ticket by one developer. But I made the experience that exactly that happens - one developer gets the task of "build the project", locks themselfes in a dark room and emerges after weeks with a barebone of a project every other team member is forced to use from that point on. 

## Defining Architecture and their Requirements
From my idealistic point of view, the architecture decisions should be discussed in the team, after understanding the idea of the product, to design an agile architecture that is flexible enough to be iterated on. 
For this to work, achritecture can not be define the same way as in Waterfall projects in which the architecture was designed and set in stone before the first ticket was started. "The software architecture isn't a set of diagrams, it's not a set of review meetings, it's not a software architecture document, but it is a set of decisions that the team makes about some critical aspects of the system". [^continousArchitecture]

[^continousArchitecture]:[Continuous Architecture with Kurt Bittner and Pierre Pureur](https://www.infoq.com/podcasts/continuous-architecture/)

### Capturating and Documenting Architecture

Viewing Architecture as a set of decisions makes the Architecture Decision Records a very relatable way of documenting architecture. 
Drawing fancy diagrams - something I am very enjoy to do - is a great way to document how a system is working, but often enough the question why it was build this way is the more important question if developers see themselves confronted with the need for change. 

{{<alert>
Architecture Design Records: A set of point in time documentations of architectural decisions, usually stored in the code base to get information on the thoughts and reasons why the code was implemented in a certain way. Some more information here XXXXXXXX
</alert>}}

The boundary of architectural decision in contrast to an implementation decision is not easy, by may be defined for practical reasons - if the cost of changing a desicion, it is probably an architectural decision.

### Architecture Perspectives for Requirements

While Agile Methodoolgies provide a wide range of tools to define the requirements for products from a user and a business perspective; they often lack the perspective of an architect, future developer, or tester. 
When formulating the User Story, the architectural requirements are often left out, which means in agile they are invisible for time constraints, deadlines, and work recognition. 

Some examples of these requirements, that highly interfer in the the architecture: 
* As Developer I want to be able to understand the architecture of the project easily and want easy ways to add unplanned features
* As an Security Expert, I want to the project to use the company Identity provider to authenticate without static credentials
* As Testing Expert, I want to test the API independently from the Client
* As Database Expert, I want to utalize Query and Command Segregation as I want to handle the future databse performance by using read replica
* As an Interface Expert, I want to communicate with this third party service using a shared Queue
* As a third party user of the service, I want an Open Api definition first aproach to have a priorisation of API Interface
* As an Deployment Expert, I want to be able deploy an independ instance of the project with mocks to test single branches
* As Developer, I want the system to be controllabe and observable on production


These requirements match partially with the idea of non-functional requirements; but functional requirements do not by definition have the major impact on development cost.
Architectural / Design Requirements may enable or stop non functional requirements, and functional requirements should be consulted to create architectural decisions. How many microseconds a request may take is a non-functional requirement that may  be satisfied without making costly future decisions. As sidenote, the idea of framing non-functional requirements in a quantitave, measurable, testable number (target number and unacceptable number) also udnerlines that these requirements are revisited regularly, influenced by the architecture, but not causing architectural changes per se  [^nonFuncReqs]. 

[^nonFuncReqs]: [Non Functional Requirements](https://scaledagileframework.com/nonfunctional-requirements/)

## How to design Agile Architecture
### Minimal Viable Architecture

Similar to the concept of a Minimum Viable Product, the idea of a Minimum Viable Architecture is to deliver an architecture that fulfills the in the current point in time relevant requirements. This architecture is than iterated over in the upcoming features and requirements.[^mva]

[^mva]: [Minimal Viable Architecture](https://continuousarchitecture.com/2021/12/21/minimum-viable-architecture-how-to-continuously-evolve-an-architectural-design-over-time/)

* *Model the architecture*: The Model should be a tool for communication (not documentation)
* *Consider Alternatives*: Following the LEAN principles, discuss more than one option and consider drawbacks and benefits
* *Mind Cordways Law*: Companies tend to implement systems that reflect their communication structure. If there is no functioning communication structure to the team that builds the service that your system requires, the implementation might reflect that
* *Architect for change*: The Architecture will change within the agile process, it can not and should not be defined in a way that eliminates future opportunities
* *Mind testability, deployability, and developer usability*: The Devs, Testers, and Infras are the users of the architecture that is build. It should be clear and easy to use it. 
* *Keep minimal viable*: Travel light - Making too many decisions too early might restrict future implementations. If there is a decision that might as well be set in stone later, delay it

### Feedback loops

Looking at the former requirements, the respective user may be asked if the decisions led to the desired quality attributes. When a new Developer joins the team, is the code structure easy to follow and udnerstand? How clear is it for the tester how to confirm the testability? How easy is the project deployed and how often does the architecture decisions cause interruptions? Do the current devs enjoy working in the architecture?

Refining such quality attributes and assess them across teams might be the modern interpretation of an architect role. 

## Conclusion

Architecture is no longer step in development, but a continous process of iterative decisions. As those decisions happen in strong coupling with the current product requirements and the developers who are working on the code it can and should not be practiced in a closed room, but in an open space. Architecture decisions should be documented, evaluated, experimented, and assesed. 

Happy Coding :)
