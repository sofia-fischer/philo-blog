[{"content":"TLDR: Scopes are nice, but by extending the Eloquent Builder for a Model enables you to add custom, model-specific methods that are often used or should have a central definition  Scopes are great, but \u0026hellip; # Local scopes allow you to define common sets of query constraints that you may easily re-use throughout your application; read more in the Laravel Docs. Also, if you want to have a definition of a scope in one central place to maybe come back and change in at one place, instead of everywhere - a common example in practise is an activeUser scope (email confirmed? password not older than one year? \u0026hellip; ).\nScopes are great, but have two major drawbacks from my point of view: #1 no autocompletion / no \u0026ldquo;jump in your code by clicking\u0026rdquo; on it, no type hinting. This is because drawback #2 they are executed by Laravel magics. The Framework checks if the method you are trying to call is defined in scope\u0026lt;yourMethodNameInCamelCase\u0026gt; in the model and uses it then.\n   Repository Pattern: One of many Software Design Patterns out there. The Repository is an abstraction Layer of Data, from this abstraction Layer the data may be retrieved using function like Post::getAll() or in the case of Eloquent Post::all(). Most implementations of the Repository pattern I found are doing the above step of overwriting Eloquent methods with their own getAll method. But instead of overwriting the Eloquent methods, why not just extend them?  Writing a Repository that Extends the Eloquent Builder # The Builder that Laravel uses behind every ::query() is the Illuminate\\Database\\Eloquent\\Builder. A class that extends this Builder for one Model offers the opportunity to add custom methods to the Builder.\nCompared to Scopes I want to highlight, that neither the Scope Prefix is needed, nor the $query parameter.\nnamespace App\\Models\\Builders; use App\\Models\\User; use Illuminate\\Database\\Eloquent\\Builder; /** * @template TModelClass of \\App\\Models\\Post * @extends Builder\u0026lt;TModelClass\u0026gt; */ class PostBuilder extends Builder { public function published(): self { return $this-\u0026gt;where(\u0026#39;published\u0026#39;, 1); } public function whereHasMedia(): self { return $this-\u0026gt;where(fn (self $query) =\u0026gt; $query -\u0026gt;whereHas(\u0026#39;image\u0026#39;) -\u0026gt;orWhereHas(\u0026#39;video\u0026#39;) ); } public function visibleToUser(User $user): self { return $this-\u0026gt;published() -\u0026gt;where(fn (PostBuilder $query) =\u0026gt; $query -\u0026gt;where(\u0026#39;privacy\u0026#39;, \u0026#39;public\u0026#39;) -\u0026gt;when($user-\u0026gt;isAdmin(), fn (PostBuilder $query) =\u0026gt; $query -\u0026gt;orWhere(\u0026#39;privacy\u0026#39;, \u0026#39;friends\u0026#39;) ) ) ); } } This will not work out of the box, how should Laravel know that we don\u0026rsquo;t want to use the Eloquent Buidler?\nTo solve this we first have to overwrite the query Method to get the Typehints and autocompletion. Secondly we have to overwrite the Model newEloquentBuilder method. Inside the Illuminate\\Database\\Eloquent\\Model this methods usually initiates a new \\Illuminate\\Database\\Query\\Builder using the $query parameter. As our PostBuilder extends this Class, we can just use it the same.\nclass Post extends Model { /** * @return PostBuilder\u0026lt;\\App\\Models\\Post\u0026gt; */ public static function query(): PostBuilder { return parent::query(); } /** * @param \\Illuminate\\Database\\Query\\Builder $query * @return PostBuilder\u0026lt;\\App\\Models\\Post\u0026gt; */ public function newEloquentBuilder($query): PostBuilder { return new PostBuilder($query); } ... Enjoy the Usage # Let\u0026rsquo;s feel the joy of what we have implemented:\n$posts = Post::query() -\u0026gt;visibleToUser(Auth::user()) -\u0026gt;paginate(); $latestPostedImage = Post::query() -\u0026gt;where(\u0026#39;user_id\u0026#39;, 41) -\u0026gt;whereHasMedia() -\u0026gt;published() -\u0026gt;latest() -\u0026gt;first(); $latestPostedImage = $user-\u0026gt;posts()-\u0026gt;published()-\u0026gt;first(); $userWithPublishedPosts = User::query() -\u0026gt;whereHas(\u0026#39;post\u0026#39;, fn (PostBuilder $query) =\u0026gt; $query-\u0026gt;published($user)) -\u0026gt;get(); Can you feel it? No, you can\u0026rsquo;t - you have to try it to get the satisfying feeling of your IDE proposing the Model-dependent extra methods like \u0026lsquo;published\u0026rsquo; while typing, or when you go through old or unknown code the possibility to click on the method and get directly to the implementation without any Laravel Plugin or searching for a ScopeMethod.\nThere a some additional things to mention:\n If you don\u0026rsquo;t use the query Method (like Post::first()) the newEloquentBuilder Method will be called anyway, but you don\u0026rsquo;t have Typehints Usage of the two patterns are the same, the main different is the way ScopeMethods are implemented and the two extra Methods in the Model In case your super high complexity Project can utilize it: Builder classes may share traits ;)  ","date":"14 May 2022","permalink":"/posts/2022-05-14-repository-pattern/","section":"Posts","summary":"TLDR: Scopes are nice, but by extending the Eloquent Builder for a Model enables you to add custom, model-specific methods that are often used or should have a central definition  Scopes are great, but \u0026hellip; # Local scopes allow you to define common sets of query constraints that you may easily re-use throughout your application; read more in the Laravel Docs.","title":"Repository Pattern in Laravel for Query Organisation - an Alternative to Scopes"},{"content":"TLDR: I got the task to implement a Demo environment, learned something about Laravel Factories and the usage of an environment to give possible customers / investors a taste of your product and the developers to find response time / query problems and UX bugs  A \u0026ldquo;Demo\u0026rdquo; Feature Request # This card was proposed in a sprint planning and sparked a discussion around multiple problems and ideas.\n As a future Analytics-Component User I want to see a version of the Analytics-Component fully functional with generated data, so that I can see how the page would look like, before I buy the Analytics Component\n First, the ideas: this company sold a software platform with one of its components being a set of graphs, statistics, and informative texts to display the usage of the other platform features. The Analytics Component was not meant for intern analytics, but a feature set for business customers. Allowing business customers to play around with such a page before making decisions is a nice to have feature - who dislikes demos? A nice demo page is reachable for the interested customer, can\u0026rsquo;t break - even if the customer has no idea what they are doing, and should display as many features as possible accurately, up-to-date, and in sense-full context.\nThen, the discussion: We sure will not re-build the multi-page Analytics Component with some mocked graphs to only forget about updating it whenever we add a page to the real product. After some discussion we want to generate (only the needed) data to display all graphs and information correctly, but sure don\u0026rsquo;t want any of it to be in our production database. So we decided the best thing to do is to set up a demo environment that became part of our pipelines and would receive the same features while holding the maximum workload one customer could cause. The demo account would be reachable to potential customers by offering the demo user credentials and link to the environment, so the future customer could play around with the page without breaking anything.\nImplementation # Setting up a cost-efficient small server, building some pipelines, and branching a new \u0026lsquo;demo\u0026rsquo; branch from master. Before starting the implementation I would like to set some constraints on the task. The Analytics Component could was displaying data starting from yesterday, and keep historical data up to one year. The data required was a mix of multiple models - a great thanks to the business for allowing the dev team to refactor most of the respective data to an Event-Sourced pattern some weeks ago. The Component should work and display data every day, so there had to be a job to generate new data every night. So what I build was:\n A Command triggered by every deployment to re-generate the data if needed, e.g. if a feature changed an additional data had to be generated A Job to run every night (as nobody was relying on the server one slow job would be fine). This job generates new data every day, and deletes every data that is older than a year.  Laravel Usage of Factories #    Laravel Learning: Cascading Factories  Factories are a great way to generate data. One problem I run into was writing a factory that could also generate the corresponding EventS-ource Model. Event Sourcing in one sentence describes a pattern in which the changes of a state are stored in a database. Imagine we have Users who can collect Experience Points by playing Games. Instead of increasing a column in the users table, or summing up the score column of the games table (because maybe there are more ways to earn points), we create a table experiences which holds the user who earned points, the cause of points and the number of points earned. This can be a great pattern if you plan on having some analytics (which then only need to query one table), or want to leverage the \u0026ldquo;event\u0026rdquo; part of the pattern and have multiple background/ async jobs happening whenever the state is changing.\nThe corresponding factory to generate games with experiences would be:\nclass GameFactory extends Factory { protected $model = Game::class; public function definition(): array { return [ \u0026#39;user_id\u0026#39; =\u0026gt; User::factory(), \u0026#39;score\u0026#39; =\u0026gt; random_int(0, 100), ]; } public function withExperience(): self { return $this-\u0026gt;afterCreating(fn (Game $game) =\u0026gt; Experience::factory()-\u0026gt;create([ \u0026#39;game_id\u0026#39; =\u0026gt; $game-\u0026gt;id, \u0026#39;user_id\u0026#39; =\u0026gt; $game-\u0026gt;user_id, \u0026#39;created_at\u0026#39; =\u0026gt; $game-\u0026gt;created_at, \u0026#39;updated_at\u0026#39; =\u0026gt; $game-\u0026gt;updated_at, ])); } } And it could be used like this:\n$game = Game::factory()-\u0026gt;withExperience()-\u0026gt;create(); About generating data with context # Generating random data is tricky. There are some learnings I want to share while I wrote the job:\n Whenever it makes sense, after generating a bunch of models I invalidated and soft-deleted a subset of those. This helped to get a realistic view and I hoped I could spot a bug if did so. When working with data created every day I had a look at the average user - in this case people were more active on weekdays compared to weekends. This is no simulation, I avoided holidays or anything, but a small line with the integrated Carbon function was easy enough to give some realistic flow in the data $date-\u0026gt;isWeekend() ? random_int(2, 15) : random_int(45, 101) The Pages of the Analytics Component were my guide on how to vary the data - when the UX Designer worked on this, what data did they or the business expect? If there was a ranking I decided in the implementation which subset of models would be used more often to from relations to have live-like rankings. Keep it simple: Whenever there was a model that was not in any way needed to display the Analytics Component - I would not seed it.  Using the Demo Env as Stress Test and Bug Revealer # Some writing of colorful text on dark background later we deployed and watched the system taking disturbing 16 seconds to load some pages. Did I mention that the company was a Start-Up without a customer who had been causing data of that size for a year? The product owner opened a fresh pack of post-its to note down every end-point that required query optimisation as we developers got shameful credit for the not scalable system we had built. Additionally, not all graphs that we did imagine worked out with that many data points, while some other inspired completely new ways do structure the data.\n   Development Process Learning: Having a demo environment with generated data can point out response time problems, visualisation problems and be an inspiring point of view for UX and Code Development  The query optimisation was not too hard, avoid over-fetching, let SQL do whatever it can to faster than PHP, and use eager loading whenever possible. The big learning of this experience was not how I optimised the queries, but how the bottleneck was discovered. The reason I write this article is, that I recommend any high aiming Start Up to try this. Not only is it a nice feature to present your investors a view on your page \u0026ldquo;if people would use it\u0026rdquo;, but also it can uncover some bottlenecks you mind not have thought of in an early stage but would regret in case of that exponential growth the business owner is promising next month.\n","date":"11 May 2022","permalink":"/posts/2022-05-11-demo-env/","section":"Posts","summary":"TLDR: I got the task to implement a Demo environment, learned something about Laravel Factories and the usage of an environment to give possible customers / investors a taste of your product and the developers to find response time / query problems and UX bugs  A \u0026ldquo;Demo\u0026rdquo; Feature Request # This card was proposed in a sprint planning and sparked a discussion around multiple problems and ideas.","title":"Demo Environments and what I learned from implementing one"}]