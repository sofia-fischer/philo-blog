[{"content":"Driver-based Development is a coding pattern that is common in the Laravel world and used in multiple instances in the framework. It\u0026rsquo;s important to understand how Drivers and Managers work to understand how the framework solves some problems, but it\u0026rsquo;s also a nice pattern to keep in mind for example to write tests that usually work with third-party APIs  Manager and Driver Pattern (ad other Patterns) # I started the research for this post to learn more about the software patterns. After my last learning on the usage of the Repository Pattern in this post about something similar to the Repository Pattern. So to keep this from happening, I want to give a small overview of the patterns that crossed my research path. This resulted in some learning, some confusion, and a somewhat understanding of the different patterns that people associated with the Driver Pattern. Keep in mind, in the end, Software Patterns are proven concepts that solve common problems in programming.\n   Builder Pattern # The Builder Pattern enables the build-up of complex objects, the most common example would be the ORM Eloquent. Every Laravel developer has used it to build the complex object representation of a SQL query. Another example are Laravel Factories, which also use a number of methods to create a complex object in a readable way. I recommend this post to learn more.\n$users = User::factory() -\u0026gt;has(Post::factory()-\u0026gt;count(3)) -\u0026gt;suspended() -\u0026gt;make(); Provider Pattern # The Provider Pattern has more definitions than I expected\u0026hellip; It can refer to the Data Provider pattern I used in Flutter and Angular to store and hold data; it may refer to the encapsulation of methods that do different things like a plugin or STK; or in the Laravel world Provider refer to application bootstrapping and configuration, they register routes, singletons, or bind listeners to events. I recommend asking the person who mentioned it to explain to what they refer.\nFactory Pattern # The Factory Pattern (not Laravel Factories!) enables the creation of various types of objects on runtime. The decision on which precise class to create is done during runtime, but usually the same in different environments. It can be powerful if you don\u0026rsquo;t know which type of object to create, e.g. if the client may decide this; or you want to have the creation of multiple objects in one class to localise them or share functions they both need. I recommend this post to learn more\nProductFactory::build(\u0026#39;Computer\u0026#39;); The Driver Pattern in contrast to all of them # Different Drivers enable different implementations to perform the same tasks. The most common example is sending messages using different services. A driver could be sms, one mail, and one push notification. The task is always sending the message to the given set of users, but the implementation is different, other third-party APIs might be used and sometimes the decision of which driver to use is done on runtime. Another example in the Laravel world is the Cache Driver that stores your cache in redis or table, or the Database Driver that translates your Eloquent to mySql or  pgsql.\nMessage::channel(\u0026#39;mail\u0026#39;) -\u0026gt;to($user) -\u0026gt;content(\u0026#39;Do not think about pink elephants\u0026#39;) -\u0026gt;send(); Now about the different Patterns: This code utilizes the Builder Pattern to set the properties of the object step by step, but the Driver Pattern Magic happens just in the first line which determines how the message is sent. In the Driver class itself somewhere the implementation of the sending must be, and there I would call some Service class or library for actually sending emails and another one for sending SMS. The Factory Pattern might look similar at first sight as it also creates an object on runtime based on a string, but the Factory Pattern aims to instantiate Models while the Driver Pattern aims to instantiate classes that offer defined functionalities.\nWhen to use a Driver Manager Solution # The most common answer to this question I found was:\n A driver-based service is the right choice when the same utility can be provided by more than one technology. Source\n So whenever you discover a problem that might now (or in the future) be solved by multiple or changing technologies, this pattern can make it easy and simple to switch between the technologies depending on runtime decisions, database entries, or environment variables.\nBut there is more! I want to emphasize two other options when this pattern can be a handy tool:\nTesting and local development can be a non-trivial task if you use third-party APIs or your own Micro Services. During tests (and sometimes during local development) you don\u0026rsquo;t care about the correctness of the technology you are using, and maybe don\u0026rsquo;t even want to trigger any outside communication. Based on your Environment (testing or local) you can then switch to a FakerDriver that maybe can be configured in the test to simulate a long request, a wrong answer, or just correct behavior.\nA-B Testing of Services The first time I came in contact with this pattern, one of the reasons (besides many others) why we went for this pattern was the easy implementation of an A-B Test of a new Recommendation System. In a situation in which you have two technologies to do the same job, but want to compare how the users react to both of them you can implement a Driver pattern to let different users use different technologies and compare the individual engagement rate of features for different user groups.\nImplementation # Folder Structure # Here is the plan: The two Driver are FakeDriver and HugoDriver (No need to search for that name, I just made it up). To ensure the next developer who implements a Driver will implement everything we need, the RecommenderContract defines which methods should be in a Driver. The RecommenderManager is the file in which we define which string causes the instantiation of which Driver, and which Driver is the Default. And the Recommender is the Facade we will be using in practice.\nSupport └─── Drivers │ │ RecommenderContract.php │ │ FakeDriver.php │ │ HugoDriver.php │ └─── Facades │ │ Recommender.php │ └─── Managers │ RecommenderManager.php To now understand the implementation I would like to follow the code starting with the usage I aim for.\n// using default driver Recommender::recommendationsForUser($user); // using custom driver Recommender::driver(\u0026#39;hugo\u0026#39;)-\u0026gt;recommendationsForUser($user); Facade # To achieve this code, we first need a Laravel Facade. This Facade will call the Recommender Manager.\n In a Laravel application, a facade is a class that provides access to an object from the container. The machinery that makes this work is in the Facade class. Laravel\u0026rsquo;s facades, and any custom facades you create, will extend the base Illuminate\\Support\\Facades\\Facade class.\n As so often I recommend to type-hint all methods to utilize autocompletion as well as the possibility to \u0026ldquo;click through\u0026rdquo; your code easily.\nuse Illuminate\\Support\\Facades\\Facade; /** * Class Recommender * * @method recommendationsForUser(array $models, ?int $userId = null) * @see \\App\\Support\\Drivers\\HugoDriver::recommendationsForUser() * @method driver(string $name) * * @see \\App\\Support\\Managers\\RecommenderManager */ class Recommender extends Facade { protected static function getFacadeAccessor() { return RecommenderManager::class; } } Manager # The Manager defines which Driver is initiated. For this extend the Illuminate\\Support\\Manager. To implement this class you need to define the method getDefaultDriver. If you want a different default per environment, this would be the place to either return a config value or an environment variable. Then you need one method per Driver you want to build. The Illuminate Manager will guess the method name based on the string you put in (e.g. 'fake') using  $method = 'create'.Str::studly($driver).'Driver';.\nuse Illuminate\\Support\\Manager; class RecommenderManager extends Manager { public function getDefaultDriver(): string { return env(\u0026#39;RECOMMENDER_DRIVER\u0026#39;, \u0026#39;fake\u0026#39;); } public function createHugoDriver(): HugoDriver { return new HugoDriver(); } public function createFakeDriver(): FakeDriver { return new FakeDriver(); } } One step is missing until this is working - registering the Manager. This is done using a Laravel Service Provider. As I don\u0026rsquo;t plan to use the Recommender functionality in every request I made it a deferred Provider.\n If your provider is only registering bindings in the service container, you may choose to defer its registration until one of the registered bindings is actually needed. Deferring the loading of such a provider will improve the performance of your application, since it is not loaded from the filesystem on every request.\n use Illuminate\\Support\\ServiceProvider; use Illuminate\\Contracts\\Support\\DeferrableProvider; class RecommenderServiceProvider extends ServiceProvider implements DeferrableProvider { public function register(): void { $this-\u0026gt;app-\u0026gt;singleton(RecommenderManager::class, fn ($app) =\u0026gt; new RecommenderManager($app)); } public function provides(): array { return [RecommenderManager::class]; } } Driver # The Facade calls the Manager, and the Manager decides which Driver to call, now the Driver is missing implementation. This is very straightforward. Whatever Hugo does, Hugo does it here!\nuse Illuminate\\Support\\Collection; class HugoDriver implements RecommenderContract { public function recommendationsForUser(array $models, ?int $userId = null): Collection { // implement magic here  return collect([]); } } Additional # As I mentioned I use this to test my code if it utilises third-party technology. So when I write a FakeDriver I implement additional methods, that allow me to fake different states, time delays, or other things. Sure, you can also write tiny Unit Tests to test such behaviors, I made the best experience with feature tests and this method of faking data during the tests.\nHappy Coding # This was my two cents on Manager and Drivers, and the way I implemented it. When I discovered the pattern I read through this post by Orobo, as well as this on by Valerio.\nIf you spot an error, please don\u0026rsquo;t hesitate on enlighten me,\nHappy Coding :)\n","date":"22 May 2022","permalink":"/posts/2022-05-driver-manager-pattern/","section":"Posts","summary":"Driver-based Development is a coding pattern that is common in the Laravel world and used in multiple instances in the framework.","title":"Manager and Driver Pattern - pattern, implementation, and usage"},{"content":"Programmer giving Relationship Advice - A summary about Laravel / Eloquent relationships including some hints, advanced techniques to use and misuse relations  Relationships are great # Relational Databases like mySql or postgres tend to have that thing called relations. There are used in almost all Laravel Projects with a database and most Laravel developers know them and know how to use them. But not every developer knows the Laravel Docs by heart and there are even some features that are not mentioned in the Laravel Docs at all, but can only be discovered by clicking through the Eloquent code.\n   This blog post wants to sum up the basic relations Eloquent offers, hinting at some special ways to define relations and advanced techniques to create relations that might be useful for querying. However, this post does not cover the usage of relations, their benefits for query optimization, or general explanations of how they work (for learning that I recommend the Laravel Docs or this Blog Article) - only the definition of them.\nExample Database structure # Let\u0026rsquo;s play a game, shall we? Let\u0026rsquo;s have some games, each with a hostPlayer, some players who belong to a game and a user. A game consists of multiple rounds, in each round one player is active, and all players may make a move resulting in a score per round.\nClass diagram # classDiagram Move -- Round : Round has many Moves,  Move belongs to a Round Round -- Player : Player has many Rounds as Active-Player,  Round belongs to an Active-Player Round -- Game : Game has many Rounds,  Round belongs to a Game Move -- Player : Player has many Moves,  Move belongs to a Player Player -- Game : Game has many Players,  Player belongs to a Game Game -- Player : Player has many Games as Host,  Game belongs to a Host-Player class Game { id host_player_id started_at } class Player { id game_id user_id color } class Round { id game_id active_player_id completed_at } class Move { id round_id player_id score }  One to One # HasOne and BelongsTo # If a model has a column containing another model\u0026rsquo;s id, forming a One to One Relationship. Every Relationship has its inverse form - if a User HasOne Level, a Level BelongsTo a User. A Model with a HasOne says \u0026ldquo;the id of mine is in on another table\u0026rdquo;, the standard example would be:\nclassDiagram User Level belongs to User class User { id email password } class Level { id user_id over_all_score }  class User extends Model { public function level(): \\Illuminate\\Database\\Eloquent\\Relations\\HasOne { return $this-\u0026gt;hasOne(Level::class); } ... } class Level extends Model { public function user(): \\Illuminate\\Database\\Eloquent\\Relations\\BelongsTo { return $this-\u0026gt;belongsTo(User::class); } ... \u0026ldquo;Creative\u0026rdquo; usage of the extra Parameters # A word on parameter naming The something_id column is called foreign_id, while the id column of this model is referred to as local_id; the model to which this foreign_id belongs is the owner model, and its id column is referred to as owner_id. In Laravel it is possible to enter alternative values (other than Laravel\u0026rsquo;s guessed values $this-\u0026gt;belongsTo(User::class, 'user_id', 'id')) for reasons like using uuids or naming conventions.\nBut you can use these parameters also in more creative ways, let\u0026rsquo;s say you want to display the level of the user next to a players icon:\nclass Player extends Model { public function level(): \\Illuminate\\Database\\Eloquent\\Relations\\HasOne { return $this-\u0026gt;hasOne(Level::class, \u0026#39;user_id\u0026#39;, \u0026#39;user_id\u0026#39;); } ...    The idea of \u0026ldquo;misusing\u0026rdquo; relations in this way is considerable, strange, not intuitive for readers, and confusing for beginners - so maybe just don\u0026rsquo;t do them. With this blog post I just want to point out, that this way of working with relationships is possible, works for some cases great, and is kinda fun to think about.  If I need the relation (for eager loading, query optimization\u0026hellip;) it is handy to take the shortcut of just using the user_ids. The problems I want to point out:\n Using the create function will not create a user, and honestly, I have no idea what would happen or which id would be set there This query will not check if the user exists or is deleted  Default Models # Both HasOne and BelongsTo relations may have a default which (for example for a level) comes in handy because you don\u0026rsquo;t have to store a model for a user who maybe never plays a game.\npublic function level(): \\Illuminate\\Database\\Eloquent\\Relations\\HasOne { return $this-\u0026gt;hasOne(Level::class)-\u0026gt;withDefault([\u0026#39;overall_score\u0026#39; =\u0026gt; 0]); } One To Many # HasMany and BelongsTo # The more common One to Many relations are indistinguishable from a database perspective (if there is no unique constraint on the foreign key column). The difference is the possibility of the Owner to have more than one model belonging to it.\nclass Game extends Model { public function rounds(): \\Illuminate\\Database\\Eloquent\\Relations\\HasMany { return $this-\u0026gt;hasMany(Round::class); } ... } class Round extends Model { public function game(): \\Illuminate\\Database\\Eloquent\\Relations\\BelongsTo { return $this-\u0026gt;belongsTo(Game::class); } ... Queries in Relations # Compared to ofMany adding extra queries on the relation is possible as well and can come in quite handy:\nclass Game extends Model { public function redPlayers(): \\Illuminate\\Database\\Eloquent\\Relations\\HasMany { return $this-\u0026gt;hasMany(Player::class)-\u0026gt;where(\u0026#39;color\u0026#39;, \u0026#39;red\u0026#39;); } public function playersWithoutMove(): \\Illuminate\\Database\\Eloquent\\Relations\\HasMany { return $this-\u0026gt;hasMany(Player::class)-\u0026gt;whereDosntHave(\u0026#39;move\u0026#39;); } ... } Using HasOne-\u0026gt;ofMany # But HasOne also offers great options if you are often looking for one special model of a HasMany Relationship. This use case is very common, so I think the ofMany function is underrated.\nclass Round extends Model { // latest (current) Move  public function latestMove(): \\Illuminate\\Database\\Eloquent\\Relations\\HasOne { return $this-\u0026gt;hasOne(Move::class)-\u0026gt;latestOfMany(); } // best Move  public function latestMove(): \\Illuminate\\Database\\Eloquent\\Relations\\HasOne { return $this-\u0026gt;hasOne(Move::class)-\u0026gt;latestOfMany(\u0026#39;score\u0026#39;, \u0026#39;max\u0026#39;); } // best, latest move where score is positive  public function bestLatestMoveWithPositiveScore(): \\Illuminate\\Database\\Eloquent\\Relations\\HasOne { return $this-\u0026gt;hasOne(Move::class)-\u0026gt;ofMany( [\u0026#39;created_at\u0026#39; =\u0026gt; \u0026#39;max\u0026#39;, \u0026#39;score\u0026#39; =\u0026gt; \u0026#39;max\u0026#39;], fn ($query) =\u0026gt; $query-\u0026gt;where(\u0026#39;score\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, 0); ); } ... \u0026ldquo;Creative\u0026rdquo; One to Many Relations # Breaking it down to the minimal requirement, a HasMany relation requires that there is another table, which holds an identifier that the local table holds as well.\nIf you look at our class diagram, for example, there is no direct connection between Move and Game, if you want the moves of a game you have to use the Round as a middleman. Now let\u0026rsquo;s say I want a statistic that proves that my game is fair and that the host player does not make moves with higher scores or so - whatever reason I might have to create such a relation.\nclass Game extends Model { public function hostPlayerMoves(): \\Illuminate\\Database\\Eloquent\\Relations\\HasMany { return $this-\u0026gt;hasMany(Moves::class, \u0026#39;player_id\u0026#39;, \u0026#39;host_player_id\u0026#39;); } ...    Again, creating this kind of relationships might be smelly or hacky, but it can be handy if you keep the possibilities in mind that relations offer.  Having Things Through # Laravel provides a relation for two consecutive HasMany relations.\nclassDiagram Round -- Game : Game has many Rounds,  Round belongs to a Game Move -- Round : Round has many Moves,  Move belongs to a Round Move class Game extends Model { public function moves(): \\Illuminate\\Database\\Eloquent\\Relations\\HasManyThrough { return $this-\u0026gt;hasManyThrough(Move::class, Round::class); } ... \u0026ldquo;Creative\u0026rdquo; HasManyThroughs # Let\u0026rsquo;s say we want to display the Level of the overall Game - maybe to match with other Games or whatever. Again we can use the additional parameters to skip some tables on the way between Game and Level. Usually, we would start at the Game, and look for the players, look for the users, look for the levels. But both the levels and the players share the same user_id - why not skip the User?\nclass Game extends Model { public function levels(): \\Illuminate\\Database\\Eloquent\\Relations\\HasManyThrough { return $this-\u0026gt;hasManyThrough( Level::class, Player::class, \u0026#39;game_id\u0026#39;, // Foreign key on the players table  \u0026#39;user_id\u0026#39;, // Foreign key on the levels table  \u0026#39;id\u0026#39;, // Local key on the games table  \u0026#39;user_id\u0026#39; // Local key on the players table  ); } ...    Again, creating this kind of relationships might be smelly or hacky, but it can be handy if you keep the possibilities in mind that relations offer.  Many To Many # Many to Many relations are the kind of relations that require a pivot table. If compared to the implementation depicted in the examples above, where a user has a player per game I could have implemented a Many to Many relation using a game_user or game^user or games_2_users table or other conventional namings for pivot tables. That would look like this:\nclass Game extends Model { public function player(): \\Illuminate\\Database\\Eloquent\\Relations\\HasManyThrough { return $this-\u0026gt;belongsToMany(User::class, \u0026#39;game_user\u0026#39;); } ... The point I don\u0026rsquo;t like about this is #1 the naming convention does not reflect the meaning of the relation; I prefer calling a thing by their name, in this case, players. 2# The first thing especially bugs me after you start adding more columns in the pivot table, starting with timestamps, then maybe a soft delete, and then a custom link or so. At some point, a lot of the pivot tables I saw would have looked cleaner, and caused less code smell if they were models from the very beginning.\nThis does not mean, that many to many relations are useless. As I mentioned in the last examples, there are many ways to use the additional parameters in the relationship functions. So if you see Player as a pivot model, you can still define this relation:\nclass Game extends Model { public function users(): \\Illuminate\\Database\\Eloquent\\Relations\\BelongsToMany { return $this-\u0026gt;belongsToMany( User::class, // target model  \u0026#39;players\u0026#39;, // pivot table  \u0026#39;game_id\u0026#39;, // Foreign key on pivot player table  \u0026#39;user_id\u0026#39;, // Foreign key on pivot player table  \u0026#39;id\u0026#39;, // Parent key on the games table  \u0026#39;id\u0026#39; // Related key on the users table  ); } ... Any table with two foreign ids may be used as a pivot table!\n\u0026ldquo;Creative\u0026rdquo; Many to Many Relations # You may again use this information even further and again create sometimes useful relations by using the additional function parameters. For example, if you want to have the Levels instead of the Users of a Game.\nclass Game extends Model { public function levels(): \\Illuminate\\Database\\Eloquent\\Relations\\BelongsToMany { return $this-\u0026gt;belongsToMany( Level::class, // target model  \u0026#39;players\u0026#39;, // pivot table  \u0026#39;game_id\u0026#39;, // Foreign key on pivot player table  \u0026#39;user_id\u0026#39;, // Foreign key on pivot player table  \u0026#39;id\u0026#39;, // Parent key on the games table  \u0026#39;user_id\u0026#39; // Related key on the levels table  ); } ... Last words # This was a collection of infos, hints, and hacks about the definition of Laravel or Eloquent Relationships. If you found any mistakes or have additional tricks please feel free to contact me :D\nHappy coding\n","date":"20 May 2022","permalink":"/posts/2022-05-relationships/","section":"Posts","summary":"Programmer giving Relationship Advice - A summary about Laravel / Eloquent relationships including some hints, advanced techniques to use and misuse relations  Relationships are great # Relational Databases like mySql or postgres tend to have that thing called relations.","title":"Useful and Useless Relationship Definitions"},{"content":"Scopes are nice, but by extending the Eloquent Builder for a Model enables you to add custom, model-specific methods that are often used or should have a central definition  Scopes are great, but \u0026hellip; # Local scopes allow you to define common sets of query constraints that you may easily re-use throughout your application; read more in the Laravel Docs. Also, if you want to have a definition of a scope in one central place to maybe come back and change in at one place, instead of everywhere - a common example in practise is an activeUser scope (email confirmed? password not older than one year? \u0026hellip; ).\nScopes are great, but have two major drawbacks from my point of view: #1 no autocompletion / no \u0026ldquo;jump in your code by clicking\u0026rdquo; on it, no type hinting. This is because drawback #2 they are executed by Laravel magics. The Framework checks if the method you are trying to call is defined in scope\u0026lt;yourMethodNameInCamelCase\u0026gt; in the model and uses it then.\nAbout Patterns # Laravel Scopes are build utilizing the Builder Pattern, which enables the build-up of complex object (in this case the object representation of a SQL Query) step by step using methods to change the query bit by bit. Now, scopes are also following the pattern but in use cases in which a set of queries if performed often, they make the code more readable and maintainable.1\nRepository Pattern # One pattern is partially similar, the Repository Pattern was the closest I could find. Most times the Repository handles create, delete, and index methods, while this post focuses on index / query methods only. The only I could not find a specific Pattern I could match the custom query builder with, but\nThe Repository is an abstraction Layer of Data, from this abstraction Layer the data may be retrieved using function like Post::getAll() or in the case of Eloquent Post::all(). Most implementations of the Repository pattern I found are doing the above step of overwriting Eloquent methods with their own getAll method. But instead of overwriting the Eloquent methods, why not just extend them? 2\nWriting a Custom Builder that Extends the Eloquent Builder # The Builder that Laravel uses behind every ::query() is the Illuminate\\Database\\Eloquent\\Builder. A class that extends this Builder for one Model offers the opportunity to add custom methods to the Builder.\nCompared to Scopes I want to highlight, that neither the Scope Prefix is needed, nor the $query parameter. Additionally, this utilises the fully typed / auto-completion feature I value so much 3.\nnamespace App\\Models\\Builders; use App\\Models\\User; use Illuminate\\Database\\Eloquent\\Builder; /** * @template TModelClass of \\App\\Models\\Post * @extends Builder\u0026lt;TModelClass\u0026gt; */ class PostBuilder extends Builder { public function published(): self { return $this-\u0026gt;where(\u0026#39;published\u0026#39;, 1); } public function whereHasMedia(): self { return $this-\u0026gt;where(fn (self $query) =\u0026gt; $query -\u0026gt;whereHas(\u0026#39;image\u0026#39;) -\u0026gt;orWhereHas(\u0026#39;video\u0026#39;) ); } public function visibleToUser(User $user): self { return $this-\u0026gt;published() -\u0026gt;where(fn (PostBuilder $query) =\u0026gt; $query -\u0026gt;where(\u0026#39;privacy\u0026#39;, \u0026#39;public\u0026#39;) -\u0026gt;when($user-\u0026gt;isAdmin(), fn (PostBuilder $query) =\u0026gt; $query -\u0026gt;orWhere(\u0026#39;privacy\u0026#39;, \u0026#39;friends\u0026#39;) ) ) ); } } This will not work out of the box, how should Laravel know that we don\u0026rsquo;t want to use the Eloquent Buidler?\nTo solve this we first have to overwrite the query Method to get the Typehints and autocompletion. Secondly we have to overwrite the Model newEloquentBuilder method. Inside the Illuminate\\Database\\Eloquent\\Model this methods usually initiates a new \\Illuminate\\Database\\Query\\Builder using the $query parameter. As our PostBuilder extends this Class, we can just use it the same.\nclass Post extends Model { /** * @return PostBuilder\u0026lt;\\App\\Models\\Post\u0026gt; */ public static function query(): PostBuilder { return parent::query(); } /** * @param \\Illuminate\\Database\\Query\\Builder $query * @return PostBuilder\u0026lt;\\App\\Models\\Post\u0026gt; */ public function newEloquentBuilder($query): PostBuilder { return new PostBuilder($query); } ... Enjoy the Usage # Let\u0026rsquo;s feel the joy of what we have implemented:\n$posts = Post::query() -\u0026gt;visibleToUser(Auth::user()) -\u0026gt;paginate(); $latestPostedImage = Post::query() -\u0026gt;where(\u0026#39;user_id\u0026#39;, 41) -\u0026gt;whereHasMedia() -\u0026gt;published() -\u0026gt;latest() -\u0026gt;first(); $latestPostedImage = $user-\u0026gt;posts()-\u0026gt;published()-\u0026gt;first(); $userWithPublishedPosts = User::query() -\u0026gt;whereHas(\u0026#39;post\u0026#39;, fn (PostBuilder $query) =\u0026gt; $query-\u0026gt;published($user)) -\u0026gt;get(); Can you feel it? No, you can\u0026rsquo;t - you have to try it to get the satisfying feeling of your IDE proposing the Model-dependent extra methods like \u0026lsquo;published\u0026rsquo; while typing, or when you go through old or unknown code the possibility to click on the method and get directly to the implementation without any Laravel Plugin or searching for a ScopeMethod.\nThere a some additional things to mention:\n If you don\u0026rsquo;t use the query Method (like Post::first()) the newEloquentBuilder Method will be called anyway, but you don\u0026rsquo;t have Typehints Usage of the two patterns are the same, the main different is the way ScopeMethods are implemented and the two extra Methods in the Model In case your super high complexity Project can utilize it: Builder classes may share traits ;)  Bonus: # If custom query builders is not enough for you to play with, try customising Collections 4. If there is any set of collection methods you always use, or you are missing, you can just extend the Laravel Collections yourself!\nclass AppServiceProvider extends ServiceProvider { public function boot() { Collection::macro(\u0026#39;firstWhereMin\u0026#39;, fn (string $key) =\u0026gt; $this-\u0026gt;firstWhere($key, $this-\u0026gt;min($key))); } } I am still looking for a nice way to keep my beloved autocompletion, but for just the functionality I can recommend you to just write all the Collection methods you might miss. 5\n  In this post I write more about patterns\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n In my personal point of view the only reason to completely implement this pattern is to generate everything starting from routes, to controller, and resources based on an openApi file or so, but here is an example\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n When I looked through the web, the only blog articles I could find, which did implement this pattern where this one by Martin Joo and this one by Tim MacDonald. Both do not overwrite the query method, but every thing else is quite similar to this post.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Read through the Laravel Docs regarding this\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Spatie has a package with nice examples if you are looking for something pre-build or inspiration\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"14 May 2022","permalink":"/posts/2022-05-custom-query-builder-pattern/","section":"Posts","summary":"Scopes are nice, but by extending the Eloquent Builder for a Model enables you to add custom, model-specific methods that are often used or should have a central definition  Scopes are great, but \u0026hellip; # Local scopes allow you to define common sets of query constraints that you may easily re-use throughout your application; read more in the Laravel Docs.","title":"Model Specific Query Builder - an Alternative to Scopes"},{"content":"I got the task to implement a Demo environment, learned something about Laravel Factories and the usage of an environment to give possible customers / investors a taste of your product and the developers to find response time / query problems and UX bugs  A \u0026ldquo;Demo\u0026rdquo; Feature Request # This card was proposed in a sprint planning and sparked a discussion around multiple problems and ideas.\n As a future Analytics-Component User I want to see a version of the Analytics-Component fully functional with generated data, so that I can see how the page would look like, before I buy the Analytics Component\n First, the ideas: this company sold a software platform with one of its components being a set of graphs, statistics, and informative texts to display the usage of the other platform features. The Analytics Component was not meant for intern analytics, but a feature set for business customers. Allowing business customers to play around with such a page before making decisions is a nice to have feature - who dislikes demos? A nice demo page is reachable for the interested customer, can\u0026rsquo;t break - even if the customer has no idea what they are doing, and should display as many features as possible accurately, up-to-date, and in sense-full context.\nThen, the discussion: We sure will not re-build the multi-page Analytics Component with some mocked graphs to only forget about updating it whenever we add a page to the real product. After some discussion we want to generate (only the needed) data to display all graphs and information correctly, but sure don\u0026rsquo;t want any of it to be in our production database. So we decided the best thing to do is to set up a demo environment that became part of our pipelines and would receive the same features while holding the maximum workload one customer could cause. The demo account would be reachable to potential customers by offering the demo user credentials and link to the environment, so the future customer could play around with the page without breaking anything.\n   Implementation # Setting up a cost-efficient small server, building some pipelines, and branching a new \u0026lsquo;demo\u0026rsquo; branch from master. Before starting the implementation I would like to set some constraints on the task. The Analytics Component could was displaying data starting from yesterday, and keep historical data up to one year. The data required was a mix of multiple models - a great thanks to the business for allowing the dev team to refactor most of the respective data to an Event-Sourced pattern some weeks ago. The Component should work and display data every day, so there had to be a job to generate new data every night. So what I build was:\n A Command triggered by every deployment to re-generate the data if needed, e.g. if a feature changed an additional data had to be generated A Job to run every night (as nobody was relying on the server one slow job would be fine). This job generates new data every day, and deletes every data that is older than a year.  Laravel Usage of Factories #    Laravel Learning: Cascading Factories  Factories are a great way to generate data. One problem I run into was writing a factory that could also generate the corresponding EventS-ource Model. Event Sourcing in one sentence describes a pattern in which the changes of a state are stored in a database. Imagine we have Users who can collect Experience Points by playing Games. Instead of increasing a column in the users table, or summing up the score column of the games table (because maybe there are more ways to earn points), we create a table experiences which holds the user who earned points, the cause of points and the number of points earned. This can be a great pattern if you plan on having some analytics (which then only need to query one table), or want to leverage the \u0026ldquo;event\u0026rdquo; part of the pattern and have multiple background/ async jobs happening whenever the state is changing.\nThe corresponding factory to generate games with experiences would be:\nclass GameFactory extends Factory { protected $model = Game::class; public function definition(): array { return [ \u0026#39;user_id\u0026#39; =\u0026gt; User::factory(), \u0026#39;score\u0026#39; =\u0026gt; random_int(0, 100), ]; } public function withExperience(): self { return $this-\u0026gt;afterCreating(fn (Game $game) =\u0026gt; Experience::factory()-\u0026gt;create([ \u0026#39;game_id\u0026#39; =\u0026gt; $game-\u0026gt;id, \u0026#39;user_id\u0026#39; =\u0026gt; $game-\u0026gt;user_id, \u0026#39;created_at\u0026#39; =\u0026gt; $game-\u0026gt;created_at, \u0026#39;updated_at\u0026#39; =\u0026gt; $game-\u0026gt;updated_at, ])); } } And it could be used like this:\n$game = Game::factory()-\u0026gt;withExperience()-\u0026gt;create(); About generating data with context # Generating random data is tricky. There are some learnings I want to share while I wrote the job:\n Whenever it makes sense, after generating a bunch of models I invalidated and soft-deleted a subset of those. This helped to get a realistic view and I hoped I could spot a bug if did so. When working with data created every day I had a look at the average user - in this case people were more active on weekdays compared to weekends. This is no simulation, I avoided holidays or anything, but a small line with the integrated Carbon function was easy enough to give some realistic flow in the data $date-\u0026gt;isWeekend() ? random_int(2, 15) : random_int(45, 101) The Pages of the Analytics Component were my guide on how to vary the data - when the UX Designer worked on this, what data did they or the business expect? If there was a ranking I decided in the implementation which subset of models would be used more often to from relations to have live-like rankings. Keep it simple: Whenever there was a model that was not in any way needed to display the Analytics Component - I would not seed it.  Using the Demo Env as Stress Test and Bug Revealer # Some writing of colorful text on dark background later we deployed and watched the system taking disturbing 16 seconds to load some pages. Did I mention that the company was a Start-Up without a customer who had been causing data of that size for a year? The product owner opened a fresh pack of post-its to note down every end-point that required query optimisation as we developers got shameful credit for the not scalable system we had built. Additionally, not all graphs that we did imagine worked out with that many data points, while some other inspired completely new ways do structure the data.\n   Development Process Learning: Having a demo environment with generated data can point out response time problems, visualisation problems and be an inspiring point of view for UX and Code Development  The query optimisation was not too hard, avoid over-fetching, let SQL do whatever it can to faster than PHP, and use eager loading whenever possible. The big learning of this experience was not how I optimised the queries, but how the bottleneck was discovered. The reason I write this article is, that I recommend any high aiming Start Up to try this. Not only is it a nice feature to present your investors a view on your page \u0026ldquo;if people would use it\u0026rdquo;, but also it can uncover some bottlenecks you mind not have thought of in an early stage but would regret in case of that exponential growth the business owner is promising next month.\n","date":"11 May 2022","permalink":"/posts/2022-05-demo-env/","section":"Posts","summary":"I got the task to implement a Demo environment, learned something about Laravel Factories and the usage of an environment to give possible customers / investors a taste of your product and the developers to find response time / query problems and UX bugs  A \u0026ldquo;Demo\u0026rdquo; Feature Request # This card was proposed in a sprint planning and sparked a discussion around multiple problems and ideas.","title":"Demo Environments and what I learned from implementing one"}]